/**
 * Guardrail specification and instantiation helpers aligned with the
 * OpenAI Guardrails configuration/runtime model.
 *
 * Guardrails are registered via GuardrailSpec objects that describe the
 * guardrail's name, description, media type, configuration schema, and
 * check implementation. Configured guardrails are produced by binding a
 * specification to a validated configuration object.
 */

import { z } from 'zod';
import type {
  CheckFn,
  GuardrailContext,
  GuardrailResult,
} from './enhanced-types';

/**
 * Structured metadata describing how a guardrail behaves.
 *
 * We retain the richer metadata surface we historically exposed while
 * remaining compatible with the OpenAI registry model.
 */
export interface GuardrailSpecMetadata {
  engine?: string;
  version?: string;
  category?: 'security' | 'quality' | 'compliance' | 'performance' | 'content';
  requiresExternalApi?: boolean;
  estimatedLatencyMs?: number;
  tags?: string[];
  usesConversationHistory?: boolean;
  [key: string]: unknown;
}

/**
 * Immutable descriptor for a registered guardrail.
 *
 * The constructor arguments match the OpenAI implementation so configs
 * generated by https://guardrails.openai.com can be consumed directly.
 */
export class GuardrailSpec<
  TContext extends GuardrailContext = GuardrailContext,
  TInput = unknown,
  TConfig = Record<string, unknown>,
> {
  constructor(
    public readonly name: string,
    public readonly description: string,
    public readonly mediaType: string,
    public readonly configSchema: z.ZodType<TConfig>,
    public readonly checkFn: CheckFn<TContext, TInput, TConfig>,
    public readonly ctxRequirements?: z.ZodType<TContext>,
    public readonly metadata?: GuardrailSpecMetadata,
  ) {}

  /**
   * Return a JSON schema-like representation for tooling/SDKs.
   */
  schema(): Record<string, unknown> {
    return this.configSchema._def as unknown as Record<string, unknown>;
  }

  /**
   * Instantiate the guardrail with validated configuration.
   */
  instantiate(config: TConfig): ConfiguredGuardrail<TContext, TInput, TConfig> {
    const validated =
      this.configSchema instanceof z.ZodType
        ? this.configSchema.parse(config ?? {})
        : (config as TConfig);
    return new ConfiguredGuardrail(this, validated);
  }
}

/**
 * An executable guardrail bound to configuration.
 *
 * Mirrors the OpenAI implementation but keeps our richer result context.
 */
export class ConfiguredGuardrail<
  TContext extends GuardrailContext = GuardrailContext,
  TInput = unknown,
  TConfig = Record<string, unknown>,
> {
  constructor(
    public readonly spec: GuardrailSpec<TContext, TInput, TConfig>,
    public readonly config: TConfig,
  ) {}

  private async ensureAsync<T extends unknown[]>(
    fn: (...args: T) => GuardrailResult | Promise<GuardrailResult>,
    ...args: T
  ): Promise<GuardrailResult> {
    const result = fn(...args);
    if (result instanceof Promise) {
      return await result;
    }
    return result;
  }

  async run(context: TContext, input: TInput): Promise<GuardrailResult> {
    const startedAt = Date.now();
    try {
      const validatedContext = this.spec.ctxRequirements
        ? this.spec.ctxRequirements.parse(context)
        : context;
      const result = await this.ensureAsync(
        this.spec.checkFn,
        validatedContext,
        input,
        this.config,
      );

      // Ensure result has OpenAI-compatible info object
      const info = result.info || {};
      if (!result.info) {
        info.guardrailName = this.spec.name;
        info.mediaType = this.spec.mediaType;
      }

      return {
        ...result,
        info: {
          ...info,
          guardrailName: this.spec.name,
          mediaType: this.spec.mediaType,
        },
        context: {
          guardrailName: this.spec.name,
          guardrailVersion: this.spec.metadata?.version,
          executedAt: new Date(),
          executionTimeMs: Date.now() - startedAt,
          ...(result.context || {}),
        },
      };
    } catch (error) {
      return {
        tripwireTriggered: false,
        executionFailed: true,
        originalException:
          error instanceof Error ? error : new Error(String(error)),
        info: {
          guardrailName: this.spec.name,
          mediaType: this.spec.mediaType,
          error: error instanceof Error ? error.message : String(error),
        },
        message:
          error instanceof Error ? error.message : 'Guardrail execution failed',
        severity: 'high',
        context: {
          guardrailName: this.spec.name,
          executedAt: new Date(),
          executionTimeMs: Date.now() - startedAt,
        },
      };
    }
  }
}
